/* 3D space map output */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <omp.h>
#include "config.h"
#include "sycamera.h"
#include "sycout.h"
#include "util.h"

#ifdef USE_MPI
#	include <mpi.h>
#	include "smpi.h"
#endif

space3d_real_t *space3d_mainmap, *space3d_map;
int space3d_allocated,		/* Number of allocated pixels in 'space3d_map_X' */
	space3d_pixels=0;		/* Number of pixels (if applicable) */
enum space3d_model_type space3d_type;
char *space3d_output;
double *space3d_point0, *space3d_point1;

#pragma omp threadprivate(space3d_map,space3d_allocated)

void sycout_space3d_deinit_run(void) {
	#pragma omp critical
	{
		/* Extend 'space3d_mainmap' */
		space3d_mainmap->x = realloc(space3d_mainmap->x, sizeof(double)*(space3d_mainmap->n+space3d_map->n));
		space3d_mainmap->y = realloc(space3d_mainmap->y, sizeof(double)*(space3d_mainmap->n+space3d_map->n));
		space3d_mainmap->z = realloc(space3d_mainmap->z, sizeof(double)*(space3d_mainmap->n+space3d_map->n));
		space3d_mainmap->intensity = realloc(space3d_mainmap->intensity, sizeof(double)*(space3d_mainmap->n+space3d_map->n));

		/* Copy over map generated by this thread */
		memcpy(space3d_mainmap->x+space3d_mainmap->n, space3d_map->x, sizeof(double)*space3d_map->n);
		memcpy(space3d_mainmap->y+space3d_mainmap->n, space3d_map->y, sizeof(double)*space3d_map->n);
		memcpy(space3d_mainmap->z+space3d_mainmap->n, space3d_map->z, sizeof(double)*space3d_map->n);
		memcpy(space3d_mainmap->intensity+space3d_mainmap->n, space3d_map->intensity, sizeof(double)*space3d_map->n);

		space3d_mainmap->n += space3d_map->n;
	}
}
void sycout_space3d_init(struct general_settings *set) {
	int i;
	space3d_type = SPACE3D_MT_REAL;
	space3d_output = NULL;
	space3d_pixels = 0;

	for (i = 0; i < set->n; i++) {
		if (!strcmp(set->setting[i], "point0"))
			space3d_point0 = atodpn(set->value[i], 3, NULL);
		else if (!strcmp(set->setting[i], "point1"))
			space3d_point1 = atodpn(set->value[i], 3, NULL);
		else if (!strcmp(set->setting[i], "output"))
			space3d_output = set->value[i];
		else if (!strcmp(set->setting[i], "pixels"))
			space3d_pixels = atoi(set->value[i]);
		else if (!strcmp(set->setting[i], "type")) {
			if (!strcmp(set->value[i], "pixels"))
				space3d_type = SPACE3D_MT_PIXELS;
			else if (!strcmp(set->value[i], "real"))
				space3d_type = SPACE3D_MT_REAL;
			else {
				fprintf(stderr, "sycout space3d: Unrecognized model type: '%s'!\n", set->value[i]);
				exit(-1);
			}
		} else {
			fprintf(stderr, "sycout space3d: Unrecognized setting: '%s'!\n", set->setting[i]);
			exit(-1);
		}
	}

	if (space3d_output == NULL) {
		fprintf(stderr, "sycout space3d: No output filename specified!\n");
		exit(-1);
	}

	if (space3d_type == SPACE3D_MT_PIXELS) {
		if (space3d_pixels <= 0) {
			fprintf(stderr, "sycout space3d: The number of pixels must be set, and must be a positive integer!\n");
			exit(-1);
		}
	}

	space3d_mainmap = malloc(sizeof(space3d_real_t));
	space3d_mainmap->n = 0;
	space3d_mainmap->x = NULL;
	space3d_mainmap->y = NULL;
	space3d_mainmap->z = NULL;
	space3d_mainmap->intensity = NULL;
}
void sycout_space3d_init_run(void) {
	space3d_map = malloc(sizeof(space3d_real_t));
	space3d_map->n = 0;
	space3d_map->x = NULL;
	space3d_map->y = NULL;
	space3d_map->z = NULL;
	space3d_map->intensity = NULL;

	space3d_allocated = 0;
}
void sycout_space3d_init_particle(particle *p) {}
void sycout_space3d_step(struct sycout_data *sd) {
	if (space3d_allocated <= space3d_map->n+1) {
		space3d_allocated += SPACE3D_CHUNKSIZE;
		space3d_map->x = realloc(space3d_map->x, sizeof(double)*space3d_allocated);
		space3d_map->y = realloc(space3d_map->y, sizeof(double)*space3d_allocated);
		space3d_map->z = realloc(space3d_map->z, sizeof(double)*space3d_allocated);
		space3d_map->intensity = realloc(space3d_map->intensity, sizeof(double)*space3d_allocated);
	}

	int i = space3d_map->n++;
	space3d_map->x[i] = sd->sd->x;
	space3d_map->y[i] = sd->sd->y;
	space3d_map->z[i] = sd->sd->z;
	space3d_map->intensity[i] = sd->brightness * sd->differential;
}
void sycout_space3d_write(int mpi_rank, int nprocesses) {
	FILE *f;

#ifdef USE_MPI
	printf("[%d] (sycout space3d) Waiting for 'output ready' from previous process.\n", mpi_rank);
	smpi_wor(SYCOUT_MPIID_SPACE3D);
	printf("[%d] (sycout space3d) Received 'output ready' signal from previous process.\n", mpi_rank);
#endif

	if (mpi_rank == 0)
		f = fopen(space3d_output, "w");
	else
		f = fopen(space3d_output, "a");

	if (f == NULL) {
		perror("ERROR");
		fprintf(stderr, "ERROR: Unable to create or append to file: '%s'\n", space3d_output);
		exit(EXIT_FAILURE);
	}

	fprintf(stdout, "[%d] - Writing Space3D map list\n", mpi_rank);

	if (space3d_type == SPACE3D_MT_REAL) {
		char buffer[SPACE3D_CHUNKSIZE];
		int i, n, bufp = 0;
		for (i = 0; i < space3d_mainmap->n; i++) {
			n = snprintf(
				buffer+bufp, SPACE3D_CHUNKSIZE-bufp,
				"%.6e,%.6e,%.6e,%.6e\n",
				space3d_mainmap->x[i],
				space3d_mainmap->y[i],
				space3d_mainmap->z[i],
				space3d_mainmap->intensity[i]
			);

			/* If n >= size-of-buffer, not all
			 * characters were written, so we
			 * should release buffer and try again
			 */
			if (n >= SPACE3D_CHUNKSIZE-bufp) {
				buffer[bufp] = 0;
				fputs(buffer, f);
				bufp = 0;
				i--;
			} else bufp += n;
		}

		fprintf(stdout, "[%d] - Wrote %d particles to file\n", mpi_rank, i);

		/* Release buffer */
		buffer[bufp] = 0;
		fputs(buffer, f);
	} else {
		int imgdim2 = space3d_pixels*space3d_pixels, imgdim3 = imgdim2*space3d_pixels;
		int imgsize = sizeof(double)*imgdim3;
		fprintf(stdout, "[%d] - Requesting %d bytes of memory for 3D image\n", mpi_rank, imgsize);
		double *image = malloc(imgsize);

		/* Set image elements to 0 */
		int i, j, k, I, J, K;
		for (i = 0; i < imgdim3; i++)
			image[i] = 0;

		/* Generate image */
		int parts = 0;
		double xmin=space3d_point0[0], xmax=space3d_point1[0],
			   ymin=space3d_point0[1], ymax=space3d_point1[1],
			   zmin=space3d_point0[2], zmax=space3d_point1[2];
		for (i = 0; i < space3d_mainmap->n; i++) {
			I = (int)(((space3d_mainmap->x[i]-xmin)/(xmax-xmin)) * space3d_pixels);
			J = (int)(((space3d_mainmap->y[i]-ymin)/(ymax-ymin)) * space3d_pixels);
			K = (int)(((space3d_mainmap->z[i]-zmin)/(zmax-zmin)) * space3d_pixels);

			/* Is pixel within image? */
			if (I < 0 || I >= space3d_pixels ||
				J < 0 || J >= space3d_pixels ||
				K < 0 || K >= space3d_pixels)
				continue;

			image[I*imgdim2 + J*space3d_pixels + K] += space3d_mainmap->intensity[i];
		}

		/* Write image */
		int a, n, bufp = 0;
		double x, y, z;
		char buffer[SPACE3D_CHUNKSIZE];
		parts = 0;
		for (i = a = 0; i < space3d_pixels; i++) {

			x = xmin + ((double)i) / ((double)space3d_pixels) * (xmax-xmin);
			for (j = 0; j < space3d_pixels; j++) {

				y = ymin + ((double)j) / ((double)space3d_pixels) * (ymax-ymin);
				for (k = 0; k < space3d_pixels; k++, a++) {
					if (image[a] == 0.0) continue;

					z = zmin + ((double)k) / ((double)space3d_pixels) * (zmax-zmin);

					parts++;
					n = snprintf(
						buffer+bufp, SPACE3D_CHUNKSIZE-bufp,
						"%.6e,%.6e,%.6e,%.6e\n",
						x, y, z, image[a]
					);

					/* If n >= size-of-buffer, not all
					 * characters were written, so we
					 * should release buffer and try again
					 */
					if (n >= SPACE3D_CHUNKSIZE-bufp) {
						buffer[bufp] = 0;
						fputs(buffer, f);
						bufp = 0;
						k--;
						a--;
					} else bufp += n;
				}
			}
		}

		/* Release buffer */
		buffer[bufp] = 0;
		fputs(buffer, f);
		free(image);
	}

	fclose(f);

#ifdef USE_MPI
    printf("[%d] (sycout space3d) Done, sending 'output ready' to next process.\n", mpi_rank);
    smpi_sor(SYCOUT_MPIID_SPACE3D);

	if (mpi_rank == nprocesses-1) {
#endif
		fprintf(stdout, "[%d] - Wrote output to '%s'\n", mpi_rank, space3d_output);
#ifdef USE_MPI
	}
#endif
}

